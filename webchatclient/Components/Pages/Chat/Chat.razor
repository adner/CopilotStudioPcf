@page "/"
@using System.ComponentModel
@using Microsoft.Agents.Core.Models
@using webchatclient.Services
@inject IChatClient ChatClient
@inject CopilotStudioIChatClient CopilotStudioClient
@inject NavigationManager Nav
@implements IDisposable

<PageTitle>Chat</PageTitle>

@* <ChatHeader OnNewChat="@ResetConversationAsync" /> *@

<ChatMessageList Messages="@messages" InProgressMessage="@currentResponseMessage" IsWaiting="@isWaitingForResponse" OnAdaptiveCardInvokeAction="@OnAdaptiveCardInvokeAction">
    <NoMessagesContent>
        <div>
            🤖Custom Copilot Studio chat GUI!🤖
        </div>
    </NoMessagesContent>
</ChatMessageList>

<div class="chat-container">
    <ChatInput OnSend="@AddUserMessageAsync" @ref="@chatInput" />
</div>

@code {
    private readonly ChatOptions chatOptions = new();
    private readonly List<ChatMessage> messages = new();
    private CancellationTokenSource? currentResponseCancellation;
    private ChatMessage? currentResponseMessage;
    private ChatInput? chatInput;
    private bool isWaitingForResponse = false;

    private async Task AddUserMessageAsync(ChatMessage userMessage)
    {
        CancelAnyCurrentResponse();

        // Add the user message to the conversation
        messages.Add(userMessage);
        await chatInput!.FocusAsync();

        // Show loading state immediately
        isWaitingForResponse = true;
        var responseText = new TextContent("");
        currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);
        currentResponseCancellation = new();
        
        // Trigger UI update to show the spinner
        StateHasChanged();

        try
        {
            // Stream and display a new response from the IChatClient
            await foreach (var update in ChatClient.GetStreamingResponseAsync([.. messages], chatOptions, currentResponseCancellation.Token))
            {
                // Once we start receiving content, we're no longer just waiting
                if (isWaitingForResponse && !string.IsNullOrEmpty(update.Text))
                {
                    isWaitingForResponse = false;
                }
                
                messages.AddMessages(update, filter: c => c is not TextContent);
                responseText.Text += update.Text;
                ChatMessageItem.NotifyChanged(currentResponseMessage);
            }
        }
        finally
        {
            // Always clear the waiting state
            isWaitingForResponse = false;
        }

        // Store the final response in the conversation.
        messages.Add(currentResponseMessage!);
        currentResponseMessage = null;
    }

    private void CancelAnyCurrentResponse()
    {
        // If a response was cancelled while streaming, include it in the conversation so it's not lost
        if (currentResponseMessage is not null)
        {
            messages.Add(currentResponseMessage);
        }

        currentResponseCancellation?.Cancel();
        currentResponseMessage = null;
        isWaitingForResponse = false;
    }

    private async Task ResetConversationAsync()
    {
        CancelAnyCurrentResponse();
        messages.Clear();
        //chatSuggestions?.Clear();
        await chatInput!.FocusAsync();
    }

    private async Task OnAdaptiveCardInvokeAction(Activity invokeActivity)
    {
        isWaitingForResponse = true;
        var responseText = new TextContent("");
        currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);
        currentResponseCancellation = new();
        
        // Trigger UI update to show the spinner
        StateHasChanged();

        try
        {
            await foreach (var update in CopilotStudioClient.SendAdaptiveCardResponseToCopilotStudio(invokeActivity))
            {
                if (isWaitingForResponse && !string.IsNullOrEmpty(update.Text))
                {
                    isWaitingForResponse = false;
                }
                
                messages.AddMessages(update, filter: c => c is not TextContent);
                responseText.Text += update.Text;
                ChatMessageItem.NotifyChanged(currentResponseMessage);
            }
        }
        catch (Exception ex)
        {
            // Log error if needed
            isWaitingForResponse = false;
            responseText.Text = $"Error processing action: {ex.Message}";
        }
        finally
        {
            isWaitingForResponse = false;
            ChatMessageItem.NotifyChanged(currentResponseMessage);
        }

        messages.Add(currentResponseMessage!);
        currentResponseMessage = null;
    }

    public void Dispose()
        => currentResponseCancellation?.Cancel();
}
