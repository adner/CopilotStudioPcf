@using System.Runtime.CompilerServices
@using System.Text.RegularExpressions
@using System.Linq
@using System.Text.Json

@if (Message.Role == ChatRole.User)
{
    <div class="user-message">
        @Message.Text
    </div>
}
else if (Message.Role == ChatRole.Assistant)
{
    foreach (var content in Message.Contents)
    {
        if (content is TextContent { Text: { Length: > 0 } text })
        {
            <div class="assistant-message">
                <div>
                    <div class="assistant-message-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 18v-5.25m0 0a6.01 6.01 0 0 0 1.5-.189m-1.5.189a6.01 6.01 0 0 1-1.5-.189m3.75 7.478a12.06 12.06 0 0 1-4.5 0m3.75 2.383a14.406 14.406 0 0 1-3 0M14.25 18v-.192c0-.983.658-1.823 1.508-2.316a7.5 7.5 0 1 0-7.517 0c.85.493 1.509 1.333 1.509 2.316V18" />
                        </svg>
                    </div>
                </div>
                <div class="assistant-message-header" style="color: white; font-weight: bold;">ðŸ¤– Copilot Studio Agent</div>
                <div class="assistant-message-text">
                    <assistant-message markdown="@text"></assistant-message>

                    @foreach (var citation in citations ?? [])
                    {
                        <ChatCitation File="@citation.File" PageNumber="@citation.Page" Quote="@citation.Quote" />
                    }
                </div>
            </div>
        }
        else if (content is FunctionCallContent { CallId: "RenderAdaptiveCardAsync" } acc && acc.Arguments?.TryGetValue("adaptiveCardJson", out var cardJsonObj) is true && cardJsonObj is string cardJson)
        {
            @if (ShouldRenderSudokuCard(cardJson))
            {
                <div class="adaptive-card-container">
                    <div class="adaptive-card-content">
                        <iframe src="/sudoku.html" 
                                width="100%" 
                                height="630" 
                                frameborder="0" 
                                style="border-radius: 8px; background: #0f0f23;">
                        </iframe>
                    </div>
                </div>
            }
            else if (ShouldRenderDoomCard(cardJson))
            {
                <div class="adaptive-card-container">
                    <div class="adaptive-card-content">
                        <iframe src="/doom-crt.html" 
                                width="100%" height="630" frameborder="0"
                            style="border-radius: 8px; background: #0f0f23;">
                        </iframe>
                    </div>
                </div>
            }
        }
    }
}

@code {
    private static readonly ConditionalWeakTable<ChatMessage, ChatMessageItem> SubscribersLookup = new();
    private static readonly Regex CitationRegex = new(@"<citation filename='(?<file>[^']*)' page_number='(?<page>\d*)'>(?<quote>.*?)</citation>", RegexOptions.NonBacktracking);

    private List<(string File, int? Page, string Quote)>? citations;

    [Parameter, EditorRequired]
    public required ChatMessage Message { get; set; }

    [Parameter]
    public bool InProgress { get; set;}

    [Parameter]
    public EventCallback<ChatMessage> OnSendMessage { get; set; }

    protected override void OnInitialized()
    {
        SubscribersLookup.AddOrUpdate(Message, this);

        if (!InProgress && Message.Role == ChatRole.Assistant && Message.Text is { Length: > 0 } text)
        {
            ParseCitations(text);
        }
    }

    public static void NotifyChanged(ChatMessage source)
    {
        if (SubscribersLookup.TryGetValue(source, out var subscriber))
        {
            subscriber.StateHasChanged();
        }
    }

    private void ParseCitations(string text)
    {
        var matches = CitationRegex.Matches(text);
        citations = matches.Any()
            ? matches.Select(m => (m.Groups["file"].Value, int.TryParse(m.Groups["page"].Value, out var page) ? page : (int?)null, m.Groups["quote"].Value)).ToList()
            : null;
    }

    private bool ShouldRenderSudokuCard(string cardJson)
    {
        try
        {
            using var jsonDoc = JsonDocument.Parse(cardJson);
            var root = jsonDoc.RootElement;
            
            if (root.TryGetProperty("actions", out var actionsElement) && actionsElement.ValueKind == JsonValueKind.Array)
            {
                foreach (var action in actionsElement.EnumerateArray())
                {
                    if (action.TryGetProperty("data", out var dataElement) &&
                        dataElement.TryGetProperty("action", out var actionElement) &&
                        actionElement.GetString() == "PlaySudoku")
                    {
                        return true;
                    }
                }
            }
        }
        catch (JsonException)
        {
            // Invalid JSON, don't render the card
        }
        
        return false;
    }

    private bool ShouldRenderDoomCard(string cardJson)
    {
        try
        {
            using var jsonDoc = JsonDocument.Parse(cardJson);
            var root = jsonDoc.RootElement;
            
            if (root.TryGetProperty("actions", out var actionsElement) && actionsElement.ValueKind == JsonValueKind.Array)
            {
                foreach (var action in actionsElement.EnumerateArray())
                {
                    if (action.TryGetProperty("data", out var dataElement) &&
                        dataElement.TryGetProperty("action", out var actionElement) &&
                        actionElement.GetString() == "PlayDoom")
                    {
                        return true;
                    }
                }
            }
        }
        catch (JsonException)
        {
            // Invalid JSON, don't render the card
        }
        
        return false;
    }


    private async Task HandleConnectionResponse(bool allowed)
    {
        var adaptiveCardResponse = new
        {
            type = "AdaptiveCard",
            version = "1.5",
            body = new[]
            {
                new
                {
                    type = "TextBlock",
                    text = allowed ? "Connection allowed" : "Connection cancelled",
                    weight = "Bolder"
                }
            },
            actions = new[]
            {
                new
                {
                    type = "Action.Submit",
                    title = allowed ? "Allow" : "Cancel",
                    data = new
                    {
                        action = allowed ? "ConnectionAllowed" : "ConnectionCancelled",
                        timestamp = DateTimeOffset.UtcNow.ToString("O")
                    }
                }
            }
        };

        var responseJson = System.Text.Json.JsonSerializer.Serialize(adaptiveCardResponse);
        var userMessage = new ChatMessage(ChatRole.User, responseJson);
        
        if (OnSendMessage.HasDelegate)
        {
            await OnSendMessage.InvokeAsync(userMessage);
        }
    }
}
